# 前端开发补充规范文档

> **版本**: v1.0.0  
> **最后更新**: 2024-11-18

## 1. 概述

本文档补充了前端开发的详细规范，包括状态管理、路由管理、组件设计、Hooks使用等。

## 2. 状态管理

### 2.1 状态管理选择

#### 本地状态（useState）

适用于组件内部状态：

```typescript
const [searchQuery, setSearchQuery] = useState('');
const [isLoading, setIsLoading] = useState(false);
```

#### 全局状态（Context API / Zustand）

适用于跨组件共享状态：

```typescript
// 使用Context API
const UserContext = createContext<User | null>(null);

// 或使用Zustand（推荐）
import { create } from 'zustand';

interface UserStore {
  user: User | null;
  setUser: (user: User) => void;
  logout: () => void;
}

export const useUserStore = create<UserStore>((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  logout: () => set({ user: null }),
}));
```

### 2.2 状态管理原则

- **最小化全局状态**: 只在必要时使用全局状态
- **状态提升**: 将状态提升到最近的共同父组件
- **单一数据源**: 避免数据重复

## 3. 路由管理

### 3.1 路由定义

```typescript
// routes.ts
export const routes = {
  home: '/',
  tools: '/tools',
  demands: '/demands',
  projects: '/projects',
  projectDetail: (id: number) => `/projects/${id}`,
  profile: '/profile',
  admin: '/admin',
} as const;
```

### 3.2 路由使用

```typescript
// 使用路由常量
import { routes } from '@/lib/constants/routes';

navigate(routes.tools);
navigate(routes.projectDetail(123));
```

## 4. 组件设计规范

### 4.1 组件分类

#### 原子组件（Atoms）

最小的UI组件单元：

```typescript
// components/ui/Button.tsx
export function Button({ children, ...props }: ButtonProps) {
  return <button {...props}>{children}</button>;
}
```

#### 分子组件（Molecules）

由原子组件组合：

```typescript
// components/ui/SearchInput.tsx
export function SearchInput(props: InputProps) {
  return (
    <div className="relative">
      <Search className="absolute left-3" />
      <Input {...props} className="pl-10" />
    </div>
  );
}
```

#### 组织组件（Organisms）

由分子组件组合：

```typescript
// components/features/ToolCard.tsx
export function ToolCard({ tool }: ToolCardProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{tool.name}</CardTitle>
      </CardHeader>
      <CardContent>
        <p>{tool.description}</p>
        <Button>查看详情</Button>
      </CardContent>
    </Card>
  );
}
```

### 4.2 组件设计原则

- **单一职责**: 每个组件只做一件事
- **可复用**: 通过props配置行为
- **可组合**: 支持组合使用
- **可测试**: 易于单元测试

## 5. Hooks使用规范

### 5.1 自定义Hooks

```typescript
// hooks/useTools.ts
export function useTools(query: QueryToolDto) {
  const [tools, setTools] = useState<Tool[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    setIsLoading(true);
    api.getTools(query)
      .then(setTools)
      .catch(setError)
      .finally(() => setIsLoading(false));
  }, [query]);

  return { tools, isLoading, error };
}
```

### 5.2 Hooks命名规范

- 以 `use` 开头
- 描述性命名: `useTools`, `useAuth`, `useDebounce`

### 5.3 Hooks使用规则

- 只在组件顶层调用
- 不在循环、条件中调用
- 自定义Hooks以 `use` 开头

## 6. 类型定义规范

### 6.1 类型文件组织

```
types/
├── api.ts          # API响应类型
├── tool.ts         # 工具相关类型
├── demand.ts       # 需求相关类型
├── project.ts      # 项目相关类型
└── user.ts         # 用户相关类型
```

### 6.2 类型定义示例

```typescript
// types/tool.ts
export interface Tool {
  id: number;
  name: string;
  description: string;
  category: ToolCategory;
  type: ToolType;
  author: User;
  price: number;
  rating: number;
  createdAt: string;
  updatedAt: string;
}

export type ToolCategory = 'create' | 'data' | 'chat' | 'image' | 'video' | 'text';
export type ToolType = 'agent' | 'api' | 'external';

// API响应类型
export interface PaginatedToolResponse {
  code: number;
  data: {
    items: Tool[];
    pagination: Pagination;
  };
}
```

## 7. API调用规范

### 7.1 API客户端

```typescript
// lib/api/client.ts
import axios from 'axios';

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000,
});

// 请求拦截器
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器
apiClient.interceptors.response.use(
  (response) => response.data,
  (error) => {
    if (error.response?.status === 401) {
      // 处理未授权
    }
    return Promise.reject(error);
  }
);

export default apiClient;
```

### 7.2 API函数

```typescript
// lib/api/tools.ts
import apiClient from './client';
import type { Tool, PaginatedToolResponse } from '@/types/tool';

export const toolsApi = {
  findAll: (query: QueryToolDto): Promise<PaginatedToolResponse> => {
    return apiClient.get('/tools', { params: query });
  },

  findOne: (id: number): Promise<Tool> => {
    return apiClient.get(`/tools/${id}`);
  },

  create: (data: CreateToolDto): Promise<Tool> => {
    return apiClient.post('/tools', data);
  },
};
```

## 8. 错误处理规范

### 8.1 错误边界

```typescript
// components/ErrorBoundary.tsx
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught:', error, errorInfo);
    // 发送错误到监控服务
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }
    return this.props.children;
  }
}
```

### 8.2 错误处理Hook

```typescript
// hooks/useAsync.ts
export function useAsync<T>(asyncFunction: () => Promise<T>) {
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = useCallback(() => {
    setIsLoading(true);
    setError(null);
    asyncFunction()
      .then(setData)
      .catch(setError)
      .finally(() => setIsLoading(false));
  }, [asyncFunction]);

  return { data, isLoading, error, execute };
}
```

## 9. 性能优化

### 9.1 React.memo

```typescript
export const ToolCard = React.memo(({ tool }: ToolCardProps) => {
  return (
    <Card>
      {/* ... */}
    </Card>
  );
}, (prevProps, nextProps) => {
  return prevProps.tool.id === nextProps.tool.id;
});
```

### 9.2 useMemo和useCallback

```typescript
// 缓存计算结果
const filteredTools = useMemo(() => {
  return tools.filter(tool => tool.category === selectedCategory);
}, [tools, selectedCategory]);

// 缓存函数
const handleClick = useCallback((id: number) => {
  navigate(`/tools/${id}`);
}, [navigate]);
```

### 9.3 代码分割

```typescript
// 路由懒加载
const ToolMarketplace = lazy(() => import('./components/ToolMarketplace'));

<Suspense fallback={<Loading />}>
  <ToolMarketplace />
</Suspense>
```

## 10. 表单处理

### 10.1 React Hook Form

```typescript
import { useForm } from 'react-hook-form';

function CreateToolForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<CreateToolDto>();

  const onSubmit = async (data: CreateToolDto) => {
    await toolsApi.create(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Input
        {...register('name', { required: '名称必填' })}
        error={errors.name?.message}
      />
      <Button type="submit">创建</Button>
    </form>
  );
}
```

## 11. 国际化（i18n）

### 11.1 文本提取

```typescript
// 使用i18next
import { useTranslation } from 'react-i18next';

function ToolMarketplace() {
  const { t } = useTranslation();
  
  return <h1>{t('tools.title')}</h1>;
}
```

### 11.2 文本管理

- 所有用户可见文本提取到语言文件
- 支持中英文切换
- 文本key使用命名空间

## 12. 检查清单

- [ ] 状态管理规范
- [ ] 路由管理规范
- [ ] 组件设计规范
- [ ] Hooks使用规范
- [ ] 类型定义完善
- [ ] API调用规范
- [ ] 错误处理完善
- [ ] 性能优化实施
- [ ] 表单处理规范
- [ ] 国际化支持

---

**相关文档**:
- [设计规范](./02-设计规范.md)
- [API规范](./01-API规范.md)
- [性能优化规范](./13-性能优化规范.md)


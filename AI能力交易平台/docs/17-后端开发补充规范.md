# 后端开发补充规范文档

> **版本**: v1.0.0  
> **最后更新**: 2024-11-18

## 1. 概述

本文档补充了后端开发的详细规范，包括服务拆分、缓存策略、消息队列、定时任务等。

## 2. 服务拆分原则

### 2.1 模块边界

#### 按业务领域拆分

- `auth`: 认证授权
- `users`: 用户管理
- `tools`: 工具管理
- `demands`: 需求管理
- `projects`: 项目管理

#### 模块间通信

```typescript
// 使用服务注入
@Injectable()
export class ToolsService {
  constructor(
    private readonly usersService: UsersService,
    private readonly notificationsService: NotificationsService,
  ) {}

  async create(dto: CreateToolDto, userId: number) {
    const tool = await this.prisma.tool.create({ data: { ...dto, authorId: userId } });
    
    // 通知用户
    await this.notificationsService.create({
      userId,
      type: 'TOOL_CREATED',
      title: '工具创建成功',
    });
    
    return tool;
  }
}
```

### 2.2 共享模块

```typescript
// shared/services/email.service.ts
@Injectable()
export class EmailService {
  async sendWelcomeEmail(user: User) {
    // 发送欢迎邮件
  }
}

// 在多个模块中使用
@Module({
  imports: [SharedModule], // 包含EmailService
})
export class UsersModule {}
```

## 3. 缓存策略

### 3.1 缓存层级

#### L1: 应用内存缓存

```typescript
// 短期缓存（5分钟）
private cache = new Map<string, { data: any; expires: number }>();

getCached<T>(key: string): T | null {
  const cached = this.cache.get(key);
  if (cached && cached.expires > Date.now()) {
    return cached.data as T;
  }
  this.cache.delete(key);
  return null;
}
```

#### L2: Redis缓存

```typescript
// 中期缓存（1小时）
async getCached<T>(key: string): Promise<T | null> {
  const cached = await this.redis.get(key);
  return cached ? JSON.parse(cached) : null;
}

async setCached(key: string, data: any, ttl: number = 3600) {
  await this.redis.setex(key, ttl, JSON.stringify(data));
}
```

### 3.2 缓存策略

#### 读缓存（Cache-Aside）

```typescript
async findOne(id: number): Promise<Tool> {
  // 1. 先查缓存
  const cacheKey = `tool:${id}`;
  const cached = await this.getCached<Tool>(cacheKey);
  if (cached) {
    return cached;
  }

  // 2. 查数据库
  const tool = await this.prisma.tool.findUnique({ where: { id } });
  
  // 3. 写入缓存
  await this.setCached(cacheKey, tool, 3600);
  
  return tool;
}
```

#### 写缓存（Write-Through）

```typescript
async update(id: number, data: UpdateToolDto): Promise<Tool> {
  // 1. 更新数据库
  const tool = await this.prisma.tool.update({
    where: { id },
    data,
  });

  // 2. 更新缓存
  await this.setCached(`tool:${id}`, tool, 3600);
  
  // 3. 清除列表缓存
  await this.redis.del('tools:list');
  
  return tool;
}
```

### 3.3 缓存失效

```typescript
// 主动失效
async invalidateCache(pattern: string) {
  const keys = await this.redis.keys(pattern);
  if (keys.length > 0) {
    await this.redis.del(...keys);
  }
}

// 使用示例
await this.invalidateCache('tool:*');
```

## 4. 消息队列

### 4.1 Bull队列配置

```typescript
import { BullModule } from '@nestjs/bull';

@Module({
  imports: [
    BullModule.forRoot({
      redis: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT),
      },
    }),
    BullModule.registerQueue({
      name: 'email',
    }),
  ],
})
export class AppModule {}
```

### 4.2 队列使用

```typescript
@Injectable()
export class EmailService {
  constructor(
    @InjectQueue('email') private emailQueue: Queue,
  ) {}

  async sendWelcomeEmail(userId: number) {
    await this.emailQueue.add('welcome', { userId });
  }
}

// 处理器
@Processor('email')
export class EmailProcessor {
  @Process('welcome')
  async handleWelcome(job: Job<{ userId: number }>) {
    const { userId } = job.data;
    // 发送邮件
  }
}
```

### 4.3 队列场景

- **邮件发送**: 异步发送邮件
- **通知推送**: 批量推送通知
- **数据统计**: 异步计算统计数据
- **文件处理**: 异步处理文件上传

## 5. 定时任务

### 5.1 @nestjs/schedule

```typescript
import { ScheduleModule } from '@nestjs/schedule';

@Module({
  imports: [ScheduleModule.forRoot()],
})
export class AppModule {}

// 使用
@Injectable()
export class StatsService {
  @Cron('0 0 * * *') // 每天0点执行
  async updateDailyStats() {
    // 更新每日统计
  }

  @Cron('0 */6 * * *') // 每6小时执行
  async cleanupExpiredTokens() {
    // 清理过期Token
  }

  @Interval(60000) // 每分钟执行
  async updateCache() {
    // 更新缓存
  }
}
```

### 5.2 定时任务场景

- **数据统计**: 每日/每周/每月统计
- **缓存更新**: 定期更新热点数据缓存
- **数据清理**: 清理过期数据
- **备份任务**: 定期数据备份

## 6. 文件上传处理

### 6.1 Multer配置

```typescript
import { MulterModule } from '@nestjs/platform-express';
import { diskStorage } from 'multer';

MulterModule.register({
  storage: diskStorage({
    destination: './uploads',
    filename: (req, file, cb) => {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      cb(null, `${file.fieldname}-${uniqueSuffix}${extname(file.originalname)}`);
    },
  }),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
  },
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new BadRequestException('不支持的文件类型'), false);
    }
  },
});
```

### 6.2 文件上传处理

```typescript
@Post('upload')
@UseInterceptors(FileInterceptor('file'))
async uploadFile(@UploadedFile() file: Express.Multer.File) {
  // 验证文件
  if (!file) {
    throw new BadRequestException('文件不能为空');
  }

  // 上传到OSS（如使用）
  const url = await this.ossService.upload(file);

  return { url };
}
```

## 7. 批量操作规范

### 7.1 批量创建

```typescript
// ❌ 不推荐：循环插入
for (const item of items) {
  await prisma.tool.create({ data: item });
}

// ✅ 推荐：批量插入
await prisma.tool.createMany({
  data: items,
  skipDuplicates: true,
});
```

### 7.2 批量更新

```typescript
// 使用事务
await prisma.$transaction(
  items.map(item =>
    prisma.tool.update({
      where: { id: item.id },
      data: item,
    })
  )
);
```

## 8. 事务处理规范

### 8.1 事务使用

```typescript
async createToolWithTags(dto: CreateToolDto, tagIds: number[]) {
  return await this.prisma.$transaction(async (tx) => {
    // 1. 创建工具
    const tool = await tx.tool.create({
      data: {
        name: dto.name,
        description: dto.description,
        authorId: dto.authorId,
      },
    });

    // 2. 创建标签关联
    await tx.toolTag.createMany({
      data: tagIds.map(tagId => ({
        toolId: tool.id,
        tagId,
      })),
    });

    return tool;
  });
}
```

### 8.2 事务原则

- 保持事务简短
- 避免长时间锁定
- 处理事务失败
- 记录事务日志

## 9. 数据库连接池

### 9.1 Prisma连接池配置

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // 连接池配置在URL中
  // ?connection_limit=10&pool_timeout=20
}
```

### 9.2 连接池优化

- **连接数**: 根据服务器配置调整（默认10）
- **超时设置**: 合理设置超时时间
- **连接复用**: 使用连接池复用连接

## 10. 异步处理

### 10.1 Promise处理

```typescript
// ✅ 使用async/await
async function processData() {
  try {
    const data = await fetchData();
    return process(data);
  } catch (error) {
    this.logger.error('Process failed', error);
    throw error;
  }
}

// ❌ 避免Promise链
function processData() {
  return fetchData()
    .then(data => process(data))
    .catch(error => {
      this.logger.error('Process failed', error);
      throw error;
    });
}
```

### 10.2 并发控制

```typescript
// 限制并发数
import pLimit from 'p-limit';

const limit = pLimit(5); // 最多5个并发

const results = await Promise.all(
  items.map(item => limit(() => processItem(item)))
);
```

## 11. 检查清单

- [ ] 服务拆分合理
- [ ] 缓存策略实施
- [ ] 消息队列配置
- [ ] 定时任务配置
- [ ] 文件上传处理
- [ ] 批量操作优化
- [ ] 事务处理规范
- [ ] 连接池配置
- [ ] 异步处理规范

---

**相关文档**:
- [后端代码规范](./03-后端代码规范.md)
- [性能优化规范](./13-性能优化规范.md)
- [数据库操作规范](./24-数据库操作规范.md)

